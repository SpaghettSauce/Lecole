# Строковый тип данных (Python Only)

Строки это ключевой, особенный тип данных. О строках можно говорить очень долго, сама задача хранения и манипуляции текста порождает множество подходов к работе. Здесь мы кратко пройдёмся скорее по внешней стороне вопроса: что использует для манипуляции и видит сам программист, когда работает со строками. 

## Как они устроены? 

Говоря простейшим образом, задача хранения строк сводится к двум подзадачам:
1. Хранение и кодирование символов
2. Хранение наборов символов (строк)  

```python
# Для хранения в памяти компьютера символам присваиваются числовые коды
# То, какие коды мы используем, называется "кодировка": например UTF-8, UTF-16, ASCII, КОИ-8

a = 'A' # в языке python записывать в переменную значение строки/символа можно с помощью строковых литералов
b = "B" # для этого мы помещаем буквы в кавычки (не важно двойные или одинарные - разницы нет)

# В это время внутри переменной у нас сохраняется код, его можно узнать функцией ord()
print(ord('a'), ord(a), ord(b))

# Чтобы получить символ из кода, возпользуемся функцией chr
c = chr(98)
print("Символ 98:", c)
```
Ответ программы: 
97 65 66
Символ 98: b

Будем честны, работать с символьными кодами напрямую не приходится почти никогда, но знать о том, что они существуют нужно.   

```python
# В языке python не существует явного разделения строковых и символьных типов на уровне литералов
# Строки создаются и манипулируются таким же образом, как и символы
a = "Hello, "
b = 'world!'

print(len(a)) # Длина строки

# Строки можно конкатенировать(складывать)
print(a + b)
# Понятие вычитания для строк смысла не имеет

# строки возможно перезаписывать
a = 'Goodb'
a = a + 'y' # Даже так: новое = старое + 'y'
a += 'e, ' # Или то же, но короче
print(a)

# строки можно герерировать с помощью "умножения"
ten_zeros = '0' * 10 # повторим 10 раз
print(ten_zeros) 
```
Ответ программы: 
7
Hello, world!
Goodbye, 
0000000000

Для продвижения вперёд по теме рекомендуется ознакомиться с массивами/списками.

```python
# Логично предположить, что строки должны быть устроены внутренне похоже на коллекции вроде массивов или списков
# Методы манипуляции над строками посимвольно - совпадают с возможностями списков

c = 'Длинная строка для изысканий'
print("Длина строки:", len(c))

print(c[3]) # получаем элемент по индексу, индексация с 0

for i in range(len(c)): # индексируемся в строке по длинне
    print(c[i], end=' ') # получим доступ к каждой букве
print('')

c = 'стеклянный оловянный и деревянный солдатики коллекционировали штукатурку'
no_doubled = '' # давайте создадим строку без повторов букв по порядку
for i in range(len(c) - 1): # у последней нет соседа, если обратимся за длинну - будет ошибка
    if c[i] == c[i+1]: # если буква совпадает со следующей
        continue # проппускаем
    no_doubled += c[i]
no_doubled += c[-1] # обращение [-n] это n-я буква с конца, удобно. c[-1] - последняя буква
print(no_doubled) 

# строки, в отличии от списков, иммутабельны (неизменяемы)
# d[2] = 'и' - ошибка
d = 'ошЫбка'
d = d[:2] + 'и' + d[3:] # [:2] - от начала, до 2-х (не включая 2), [3:] - от 3-х до конца (3 включительно)
print(d)
```
Ответ программы: 
Длина строки: 28
н
Д л и н н а я   с т р о к а   д л я   и з ы с к а н и й 
стекляный оловяный и деревяный солдатики колекционировали штукатурку
ошибка

## Строковые функции

```python
from datetime import datetime, date
# Преобразования типов

# str() - привести объект к строке, представив для чтения
number = str(15) # 15, но как строка
one = str(1)
print("Теперь можем обращаться посимвольно:", number[1])
print('Ой: 15 + 1 =', number + one) # правила строк, ничего не поделаешь


# repr() - представление, сохраняющее информацию об объекте, а не только удобочитаемый вид
# Для почти всех примитив не отличается от str()
print()
datetime_now = datetime.now() # обьект типа даты и времени, именно сейчас
print(datetime_now) 
print(str(datetime_now)) # разницы никакой т.к print() всегда использует str() представление
print(repr(datetime_now)) # а так мы именно считаем, что это обьект типа даты и времени

print()
date_now = date.today()
print(date_now)
print(repr(date_now)) # разница заметна, удобно для дебага

print()
test_str = 'тайныыы    '
print(test_str) # просто печатаем содержимое строки - так мы не заметим пробелов
print(repr(test_str)) # а тут мы увидим подвох, но это полезно только в дебаге

# int() - строку(и не только) в целое число
_134 = int('134')
print(_134)
_10 = int('a', base=16) # можно указать систему счисления
print(_10)
```
Ответ программы: 
Теперь можем обращаться посимвольно: 5
Ой: 15 + 1 = 151

2024-11-03 19:02:04.838838
2024-11-03 19:02:04.838838
datetime.datetime(2024, 11, 3, 19, 2, 4, 838838)

2024-11-03
datetime.date(2024, 11, 3)

тайныыы    
'тайныыы    '
134
10

```python
# в распоряжении имеется целый набор удобных функций для манипуляции над строками

scream = 'я кричу'.upper() # к верхнему регистру
whisper = 'Я ШЕПЧУ'.lower() # к нижнему регистру
print(scream, whisper)

fruits = 'яблоки бананы груши мандарины'.split() # разбить по символу(по стандарту ПРОБЕЛ)
veggies = 'морковь-капуста-картошка'.split('-')
print(fruits, veggies)

# 'разделитель'.join(коллекция) - создать строку, склеив слова из коллекции разделителем
together = 'У меня в корзинке: ' + ', '.join(fruits + veggies) # списки можно склеивать [1, 2] + [3, 4] = [1, 2, 3, 4]
print(together)
```
Ответ программы:
Я КРИЧУ я шепчу
['яблоки', 'бананы', 'груши', 'мандарины'] ['морковь', 'капуста', 'картошка']
У меня в корзинке: яблоки, бананы, груши, мандарины, морковь, капуста, картошка

```python
right_spaces = 'зажал пробел          '.rstrip()
left_spaces = '         зажал пробел'.lstrip()
center_spaces = '    много лишнего    '.strip()
print(repr(right_spaces), repr(left_spaces), repr(center_spaces))
```
Ответ программы: 
'зажал пробел' 'зажал пробел' 'много лишнего'

## f-Строки 

```python 
# Синтаксис f-строк

# Допустим у нас есть запись о собаке и мы хотим вставить в строку значения из неё
dog = {'name': 'Кирпич', 'breed': 'дворняга', "gender": 'мальчик', 'age': 5}

is_male = dog['gender'] == 'мальчик'

# Как делать НЕ НАДО
story = 'Моего пса зовут ' if is_male else 'Мою собаку зовут ' 
story += dog['name']
story += ', он - ' if is_male else ', она - '
story += dog['breed']
story += '. Ему ' if is_male else '. Ей ' 
story += str(dog['age'])
story += ' лет.'

print(story)
```
Ответ программы:
Моего пса зовут Кирпич, он - дворняга. Ему 5 лет.

Получилось длинно, муторно и совсем непонятно. Количество програмного текста просто затмевает собой суть происходящего, даже при том, что мы вывели поле is_male. Кроме всего прочего, нам приходится следить за отступами и пробелами, генерируя такие чудесные пассажи, как: `', она - '`

```python
# Давайте сделаем по уму

# f-строка
value = 42
test = f'Просто текст, а за ним вставка - {value}' # просто вставляем значения или названия переменных в {}

dog = {'name': 'Кирпич', 'breed': 'дворняга', "gender": 'мальчик', 'age': 5}

male_inserts = ['Моего пса', 'он', 'Ему'] # Вставки мальчика
female_inserts = ['Мою собаку', 'она', 'Ей'] # Вставки девочки

is_male = dog['gender'] = 'мальчик' 
my_dog, its_breed, its = male_inserts if is_male else female_inserts # выбираем вставки, распаковываем в переменные

story = f'{my_dog} зовут {dog["name"]}, {its_breed} - {dog["breed"]}. {its} {dog["age"]} лет.' # собираем в строку
print(story)
```
Ответ программы:
Моего пса зовут Кирпич, он - дворняга. Ему 5 лет.

```python
# Он позволяет компактно составлять строки из других значений, управляя форматированием

# Допустим, у нас есть список продающихся фруктов и их цен
fruits = ['яблоки', 'бананы', 'груши', 'мандарины']
prices = [len(fr)*(n + 1) for n, fr in enumerate(fruits)] # длинна названия * (номер в списке + 1)

# Пусть мы хотим сгенерировать таблицу цен 
header = f'{"Фрукт:" : <20} Цена:' # Заголовок - вставляем слова, резервируя длинну 6 + 20
width = len(header) # 26
print(header, '-'*width, sep='\n')

for fr, price in zip(fruits, prices): # синхронно итерируем по фруктам и ценам
    name_w = len(fr)
    price_w = len(str(price))
    # название с большой буквы + отступ + цена
    print(f'{fr.capitalize()}{" "*(width - name_w - price_w)}{price}') # отступ = ширина - ширина названия - ширина цены
print('-'*width)
```
Ответ программы:
Фрукт:               Цена:

Яблоки                   6
Бананы                  12
Груши                   15
Мандарины               36
