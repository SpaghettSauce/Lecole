# Файлы

Работать с файлами уметь необходимо, это универсальный способ хранить и передавать данные.  
Стандартная библиотека Python предоставляет ОС-независимый способ работать с файлами.

## Текстовый режим 

Для считывания и записи файлов существует метод(так иногда принято называть функции) ``open(file, mode, encoding)``

**file** - путь к файлу, обычно просто строка

**mode** - строка, режим доступа к файлу:  
> Режимы чтения/записи: 
> - 'r' - только чтение (стандартное значение)
> - 'w' - запись, удаляет содержимое сначала
> - 'a' - запись, добавлять в конец 
> - 'x' - открыть только если файл не существует, в ином случае ошибка
> - '+' - чтение и запись  
> 
>Режимы формата данных: 
> - 't' - текстовый (стандартное значение)
> - 'b' - бинарный 

Примеры:  
> 'r+' - чтение и запись файла, как есть  
> 'w+' - чтение и запись, файл очищается  
> 'wx' - запись если файл не существует  
> 'rb' - считать файл как поток байт  

<br/>

**encoding** - кодировка  

Лучше не трогать, если открываешь чужой файл. В случае создания лучше указывать ``'utf-8'``. Также если имеются проблемы с чтением/записью кириллицы стандартом считается применять ``'utf-8'``. Если и в таком случае не получится считать кириллицу, то применим``'koi8_r'``. 

```python
# Файл это ресурс, требующий управления захватом/высвобождением процессом
# Его нужно обязательно закрывать, чтобы другой процесс мог его использвать

file = open("assets/shakespere.txt", mode='r')
file.close()


# Это может быть проблематично, вот, что если программа завершится вследствие ошибки и файл не будет освобождён?
# with resource: - выражение захвата ресурса, управляет открытием и освобождением файла, даже в случае ошибки

with open("assets/shakespere.txt", mode='r') as file:
    one_line = file.readline() # считать одну строку файла
    print(one_line)
    print(file.readline()) # и следующую

    print('Уже считали байт(символов):', file.tell()) # увидим нашу позиию, а именно кол-во байт уже считаных с начала файла

    all_lines = file.readlines() # считать все строки в файле в список
    print(all_lines[0]) # начало файла уже считано, так что список начинается с третьей строки

    file.seek(0) # вернёмся к началу файла
    all_lines = file.readlines()
    print(''.join(all_lines[:4])) # посмотрим первые 4 строки
```
Ответ программы: 
When forty winters shall besiege thy brow,

And dig deep trenches in thy beauty’s field,

Уже считали байт(символов): 92
Thy youth’s proud livery, so gazed on now,

When forty winters shall besiege thy brow,
And dig deep trenches in thy beauty’s field,
Thy youth’s proud livery, so gazed on now,
Will be a tatter’d weed, of small worth held:

```python
with open("assets/brodsky.txt", mode='r') as file:
    # можно итерировать по файлу с помощью for вместо readlines
    # так лучше т.к. если файл большой (гигабайт, к примеру), то мы не будем помещать его весь сразу в RAM
    # мы будем считывать его построчно, не захламляя память лишним
    once = True
    for line in file: 
        if once:
            print(repr(line)) # посмотрим на строку, увидим спецсимволы силой repr()
            print()
            once = False # разок

        print(line, end='') # раз в строках файла уже есть разрыв - '\n', то end='', чтобы не добавлять лишних разрывов
```
Ответ программы: 
'Только пепел знает, что значит сгореть дотла.\n'

Только пепел знает, что значит сгореть дотла.
Но я тоже скажу, близоруко взглянув вперёд:
не всё уносимо ветром, не всё метла,
широко забирая по двору, подберёт.
Мы останемся смятым окурком, плевком, в тени
под скамьёй, куда угол проникнуть лучу не даст,
и слежимся в обнимку с грязью, считая дни,
в перегной, в осадок, в культурный пласт.
Замаравши совок, археолог разинет пасть
отрыгнуть; но его открытие прогремит
на весь мир, как зарытая в землю страсть,
как обратная версия пирамид.
«Падаль», выдохнет он, обхватив живот,
но окажется дальше от нас, чем земля от птиц.
Потому что падаль — свобода от клеток, свобода от
целого: апофеоз частиц.

```python
import os
# Про запись

# если указано имя несуществующего файла, то мы его создадим
# 'r+' - чтение и запись
# 'utf-8' - юникод 8бит
with open('assets/new_file.txt', mode='w', encoding='utf-8') as file: 
    fruits = ['Апельсины', 'Бананы', 'Персики']
    vegetables = ['Сucumbers', 'Carrots', 'Cabbages']
    
    # пишем в файл методом file.write(str)
    # пишем подряд, никаких спецсимволов не добавляется
    for fruit in fruits:
        file.write(fruit)
        file.write(', ')
    file.write('\n') # чтобы добавить разрыв строки

    file.write(', '.join(vegetables) + '\n') # а это то же самое, только лучше

with open('assets/new_file.txt', mode='r', encoding='utf-8') as file:  
    for line in file:
        print(line, end='')

os.remove('assets/new_file.txt') # удалим
```
Ответ программы:
Апельсины, Бананы, Персики, 
Сucumbers, Carrots, Cabbages

## Бинарный режим

```python
# Применим флаг 'b' для исследования файлов на бинарном уровне

# создадим простой текстовый файл
with open('assets/text.txt', mode='w', encoding='utf-8') as file:
    file.write("алмаз") # напечатаем русским в utf-8

# в бинарном режиме нельзя указывать кодировку - это не имеет смысла
with open('assets/text.txt', mode='rb') as file:
    read_bytes = file.read() # считаем весь файл, получим неизменяемый массив байт
    
    for byte in read_bytes: # читаем байты по очереди
        # посмотрим что там внутри, chr попробует считать байт как юникод 
        # байтов будет 2x символов т.к. кириллица кодируется 2 байтами в utf-8
        print(f'{byte}({chr(byte)})', end=' ') 
    
    print('\n', ''.join([chr(b) for b in read_bytes]), 'Вот та самая ошибка кодировки')
```
Ответ программы: 
208(Ð) 176(°) 208(Ð) 187(») 208(Ð) 188(¼) 208(Ð) 176(°) 208(Ð) 183(·) 
 Ð°Ð»Ð¼Ð°Ð· Вот та самая ошибка кодировки

```python
with open('assets/text.txt', mode='w', encoding='koi8_r') as file: # закодируем другой кодировкой
    file.write("алмаз") # напечатаем русским в КОИ-8 (это эксперимент, в быту только utf-8)

with open('assets/text.txt', mode='rb') as file:
    read_bytes = file.read() 
    
    for byte in read_bytes:
        # посмотрим что там внутри, chr попробует считать байт как юникод 
        # коды другие, кодировка КОИ-8 8-битная для кириллицы, так что никакой дубликации
        print(f'{byte}({chr(byte)})', end=' ') 
    
    text = read_bytes.decode('koi8_r') # декодируем байты в кодировке оригинала
    print('\n' + text)
```
Ответ программы: 
193(Á) 204(Ì) 205(Í) 193(Á) 218(Ú) 
алмаз

```python
import os 
os.remove('assets/text.txt') # скриптик для удаления
```